<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>java on Pan'Log</title><link>https://payne4handsome.github.io/categories/java/</link><description>Recent content in java on Pan'Log</description><image><title>Pan'Log</title><url>https://payne4handsome.github.io/papermod-cover.png</url><link>https://payne4handsome.github.io/papermod-cover.png</link></image><generator>Hugo -- gohugo.io</generator><atom:link href="https://payne4handsome.github.io/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>CompleableFuture原理和源码分析</title><link>https://payne4handsome.github.io/posts/java/java-%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/compleablefuture%E5%8E%9F%E7%90%86%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://payne4handsome.github.io/posts/java/java-%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/compleablefuture%E5%8E%9F%E7%90%86%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>CompleableFuture 使用场景 CompletableFuture的定义如下：
public class CompletableFuture&amp;lt;T&amp;gt; implements Future&amp;lt;T&amp;gt;, CompletionStage&amp;lt;T&amp;gt; 我们看到CompletableFuture是实现了Future的接口的，在没有CompletableFuture之前，我们可以用FutureTask来实现一个Future的功能。那么有了FutureTask那么为什么还要有CompletableFuture呢？ 我任务主要是CompletableFuture有两个优点
CompletableFuture可以实现完全的异步，而FutureTask必须通过get阻塞的方式获取结果 CompletableFuture .supplyAsync(()-&amp;gt; 1+2) .thenAccept((v)-&amp;gt; System.out.println(v*v)); 如上面的代码所示，我们完整的任务有两个阶段，一阶段是计算1+2，二阶段是计算一阶段返回结果的平方，在整个过程中，主线程完全不需要管这个任务的执行情况，也不会阻塞主线程。但是如果用FutureTask实现如上功能如下：
FutureTask&amp;lt;Integer&amp;gt; futureTask1 = new FutureTask&amp;lt;Integer&amp;gt;(() -&amp;gt; { return 1 + 2; }); new Thread(futureTask1).start(); Integer periodOneResult = futureTask1.get(); FutureTask&amp;lt;Integer&amp;gt; futureTask2 = new FutureTask&amp;lt;Integer&amp;gt;(() -&amp;gt; { return periodOneResult * periodOneResult; }); new Thread(futureTask2).start(); Integer secondOneResult = futureTask2.get(); System.out.println(secondOneResult); 代码冗长不说，还需要get方法阻塞主线程去获取结果。以上代码只是说明CompletableFuture的异步优点，实际工作中你可以把两个任务看出两个api
CompletableFuture可以实现复杂的任务编排，请思考下面代码的执行顺序是什么？ CompletableFuture&amp;lt;String&amp;gt; base = new CompletableFuture&amp;lt;&amp;gt;(); CompletableFuture&amp;lt;String&amp;gt; completion0 = base.thenApply(s -&amp;gt; { System.out.println(&amp;#34;completion 0&amp;#34;); return s + &amp;#34; 0&amp;#34;; }); CompletableFuture&amp;lt;String&amp;gt; completion1 = base.</description></item><item><title>java.util.concurrent.locks包下锁的实现原理之ReentrantLock</title><link>https://payne4handsome.github.io/posts/java/java-%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/java-java.util.concurrent.locks%E5%8C%85%E4%B8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Breentrantlock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://payne4handsome.github.io/posts/java/java-%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/java-java.util.concurrent.locks%E5%8C%85%E4%B8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8Breentrantlock/</guid><description>一、java concurrent包下lock类图概览 红色连线的表示内部类 ![image.png](/java java.util.concurrent.locks包下锁的实现原理之ReentrantLock/8596800-037daeafe21e322b.png) 1、java并发包下面的锁主要就两个，ReentrantLock（实现Lock接口） 和ReentrantReadWriteLock（实现ReadWriteLock接口）。 2、ReentrantLock类构造函数如下, sync是Sync的实例，NonfairSync（非公平锁）和FairSync(公平锁)是Sync的子类。
public ReentrantLock() { sync = new NonfairSync(); } public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); } 3、ReentrantReadWriteLock类构造函数如下，共有三个属性，sync、readerLock、writerLock
public ReentrantReadWriteLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this); } 我们看到ReentrantLock和ReentrantReadWriteLock都的实现都依赖于sync这个对象。sync是AbstractQueuedSynchronizer的实例。AbstractQueuedSynchronizer就是java并发包下面实现锁和线程同步的基础，AbstractQueuedSynchronizer就是大名鼎鼎的AQS队列，下文我们都用AQS来表示AbstractQueuedSynchronizer。 ##二、ReentrantLock实现原理
1、如何加锁 ReentrantLock使用方式如下
class X { private final ReentrantLock lock = new ReentrantLock(); // ... public void m() { lock.</description></item><item><title>java.util.concurrent.locks包下锁的实现原理之读写锁</title><link>https://payne4handsome.github.io/posts/java/java-%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/java-java.util.concurrent.locks%E5%8C%85%E4%B8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://payne4handsome.github.io/posts/java/java-%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/java-java.util.concurrent.locks%E5%8C%85%E4%B8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E8%AF%BB%E5%86%99%E9%94%81/</guid><description>java并发包已经存在Reentrant锁和条件锁，已经可以满足很多并发场景下线程安全的需求。但是在大量读少量写的场景下，并不是最优的选择。与传统锁不同的是读写锁的规则是可以共享读，但只能一个写。很多博客中总结写到读读不互斥，读写互斥，写写互斥。就读写这个场景下来说，如果一个线程获取了写锁，然后再获取读锁（同一个线程）也是可以的。锁降级就是这种情况。但是如果也是同一个线程，先获取读锁，再获取写锁是获取不到的（发生死锁）。所以严谨一点情况如下：
项目 非同一个线程 同一个线程 读读 不互斥 不互斥 读写 互斥 锁升级（不支持），发生死锁 写读 互斥 锁降级（支持），不互斥 写写 互斥 不互斥 读写锁的主要特性： 公平性：支持公平性和非公平性。 重入性：支持重入。读写锁最多支持 65535 个递归写入锁和 65535 个递归读取锁。 锁降级：遵循获取写锁，再获取读锁，最后释放写锁的次序，如此写锁能够降级成为读锁。 ReentrantReadWriteLock java.util.concurrent.locks.ReentrantReadWriteLock ，实现 ReadWriteLock 接口，可重入的读写锁实现类。在它内部，维护了一对相关的锁，一个用于只读操作（共享锁），另一个用于写入操作（排它锁）。 ReentrantReadWriteLock 类的大体结构如下：
/** 内部类 读锁 */ private final ReentrantReadWriteLock.ReadLock readerLock; /** 内部类 写锁 */ private final ReentrantReadWriteLock.WriteLock writerLock; final Sync sync; /** 使用默认（非公平）的排序属性创建一个新的 ReentrantReadWriteLock */ public ReentrantReadWriteLock() { this(false); } /** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */ public ReentrantReadWriteLock(boolean fair) { sync = fair ?</description></item><item><title>java.util.concurrent.locks包下锁的实现原理之条件锁</title><link>https://payne4handsome.github.io/posts/java/java-%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/java-java.util.concurrent.locks%E5%8C%85%E4%B8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9D%A1%E4%BB%B6%E9%94%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://payne4handsome.github.io/posts/java/java-%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/java-java.util.concurrent.locks%E5%8C%85%E4%B8%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E6%9D%A1%E4%BB%B6%E9%94%81/</guid><description>上一篇 文章中我们分析了ReentrantLock的实现原理，今天在分析一下条件锁。条件锁的具体实现在AbstractQueuedSynchronizer的内部类ConditionObject类中，总之，java中的锁，离不开AQS的实现。条件锁一般如下使用。
class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition(); final Condition notEmpty = lock.newCondition(); final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); } finally { lock.unlock(); } } public Object take() throws InterruptedException { lock.</description></item><item><title>JAVA并发编程 线程池Executors（JDK1.7）</title><link>https://payne4handsome.github.io/posts/java/java-%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0executorsjdk1.7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://payne4handsome.github.io/posts/java/java-%E5%B9%B6%E5%8F%91%E4%B8%93%E9%A2%98/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0executorsjdk1.7/</guid><description>Java中对线程池提供了很好的支持，有了线程池，我们就不需要自已再去创建线程。如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。JAVA的线程池中的线程可以在执行完任务后，不销毁，继续执行其他的任务。所以了解Java的线程池对我们掌握并发编程是很有帮助的。
先看一下线程池框架Executors涉及到的核心类。 Executor：父类，官方表述为用来解耦任务的提交，可以自已实现，比如调用线程执行该任务，或者起一个新的线程执行该任务 ExecutorService：比父类Executor定义了更多的接口用来提交、管理、终止任务 AbstractExecutorService：提供了ExecutorService默认实现 下面我就从Executors这个多线程框架开始讲起，首先看一下Executors中主要的方法 ThreadPoolExecutor：比AbstractExecutorService提供更多的功能，特别是大量的线程创建，销毁。在性能上更优越。 Executors：工厂类，提供了几个核心创建线程池的方法。 Executors核心方法 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;()); } public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(), threadFactory); } public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;())); } public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.</description></item><item><title>java泛型</title><link>https://payne4handsome.github.io/posts/java/java%E6%B3%9B%E5%9E%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://payne4handsome.github.io/posts/java/java%E6%B3%9B%E5%9E%8B/</guid><description>java 泛型 ​很多朋友对java的泛型不是很理解，很多文章写的已不是很清楚，这篇博客对java泛型进行 一个总结。
1.泛型的转换 List foo1 = new ArrayList();//illegal
很多朋友会写出上面的代码，但会报如下错误：Type mismatch: cannot convert from ArrayList to List
尽管Interge是Number的子类，但是ArrayList不是List的子类，所以报错。下图可以很好解释这个问题。
2.java泛型的通配符? 这里可以分为两类（1）? extends T (2) ? super T.
很多朋友对这两个不是很理解，也不知道上面时候用，我们知道java中提供泛型技术，是为了提供安全检查的，使得我们写的代码更加的健壮。
2.1 ? extends T public static void print_e(List&amp;lt;? extends Number&amp;gt; list){ for(Number n : list){ System.out.println(n); } } 上面一个函数，我们可以传递如下的参数
List&amp;lt;Integer&amp;gt; list_i = new ArrayList&amp;lt;Integer&amp;gt;(); for(int i=0;i&amp;lt;10;i++){ list_i.add(i); } List&amp;lt;Double&amp;gt; list_d = new ArrayList&amp;lt;Double&amp;gt;(); for(int i=0;i&amp;lt;10;i++){ list_d.add(i+0.0); } print_e(list_i); print_e(list_d); 使得我们写的代码即具有通用型有可以提供必要的安全检查，当然print_e你可以写出如下形式，这里就不具有安全检查的效果了。
void print_e(List list) 但是经常有的朋友写出如下的代码，我们举一个stackoverflow上的一个例子：</description></item></channel></rss>